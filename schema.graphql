# type Location @entity {
# 	project: Project;
# 	erc721Address: Bytes!;
# 	locationId: string;
# 	locationName: string;
# 	priceRanges: PriceRange[];
# 	currentSupply: number;
# 	totalSupply: number;
# 	variationsTotal: Variation[];
# 	variationsMinted: Variation[];
# 	artist: string;
# }

type LostLayer @entity {
	id: ID!
	address: Bytes!
	key: Bytes!
	name: String!
	parent: LostLayer
	createdTimestamp: Int!

	# children
	lostLayers: [LostLayer!]! @derivedFrom(field: "parent")
	lostWorlds: [LostWorld!]! @derivedFrom(field: "lostLayer")
}

type LostWorld @entity {
	id: ID!
	address: Bytes!
	key: Bytes!
	name: String!
	lostLayer: LostLayer!

	# metadata
	artist: String!
	location: String!
	lat: BigDecimal!
	long: BigDecimal!
	radius: BigInt!

	# supply
	totalSupply: BigInt!
	maxSupply: BigInt!

	# timestamp
	createdTimestamp: Int!

	# variations
	variations: [Variation!]! @derivedFrom(field: "lostWorld")

	# price ranges
	priceRanges: [PriceRange!]! @derivedFrom(field: "lostWorld")

	# tokens
	tokens: [Token!]! @derivedFrom(field: "lostWorld")
}

type Token @entity {
	id: ID!
	tokenID: BigInt!
	lostWorld: LostWorld!

	# tokenURI
	name: String!
	minterLat: BigDecimal!
	minterLong: BigDecimal!
	image: String!
	imageIPFS: String!

	minter: Bytes!
	createdTimestamp: Int!

	# mutables
	owner: Bytes!
	updatedTimestamp: Int!
	# transactions: [TokenTransaction!]! @derivedFrom(field: "token");
	# isListedOnMarket: boolean;
	# price: number;
}

# type TokenTransaction @entity {
# 	from: Bytes!
# }

type PriceRange @entity {
	id: ID!
	threshold: BigInt!
	price: BigInt!
	lostWorld: LostWorld!
}

type Variation @entity {
	id: ID!
	name: String!
	count: BigInt!
	image: String!
	imageIPFS: String!
	lostWorld: LostWorld!
}
